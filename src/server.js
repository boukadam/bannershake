import {createSVGWindow} from 'svgdom'
import {SVG, registerWindow} from '@svgdotjs/svg.js'
import express from "express"
import sharp from "sharp"
import fetch from 'node-fetch'
import {readFileSync} from 'fs'
import path from 'path'
import {fileURLToPath} from 'url';
import cors from 'cors'

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const port = 8080
const logoMargin = 8
const maxBrandImageSize = 260
const lineOptions = {
    x: 380,
    yMargin: 50,
    width: 2
}

const managed = JSON.parse(readFileSync(__dirname + '/static/managed/managedLogos.json'));
const provided = JSON.parse(readFileSync(__dirname + '/static/provided/providedLogos.json'));
const availableSkills = new Map()
managed.forEach((value, _) => availableSkills.set(value.shortname, value))
provided.forEach((value, _) => availableSkills.set(value.shortname, value))

const corsOptions = {
    origin: process.env.CORS_ORIGIN?.split(','),
    optionsSuccessStatus: 200,
    methods: ['GET', 'OPTIONS', 'HEAD'],
    allowedHeaders: ['Content-Type', 'X-Requested-With', 'Accept', 'Origin', 'Access-Control-Request-Method', 'Access-Control-Request-Headers'],
};

let server = express();
server.use(cors(corsOptions))
server.get('/svg', (req, res) => respond(req, res, 'svg'));
server.get('/json', (req, res) => respond(req, res, 'json'));
server.get('/img/:shortname', async (req, res) => getImage(req, res))
server.get('/skills', (req, res) => search(req, res))
server.get('/find', (req, res) => find(req, res))

function find(req, res) {
    const {name = []} = req.query;
    const names = Array.isArray(name) ? name : [name]
    let filteredSkills = names.map(n => availableSkills.get(n))
    res.header('Content-Type', 'application/json')
    res.send({
        total: availableSkills.size,
        data: filteredSkills,
    });
}

function search(req, res) {
    const {search = '', page = 1, size = 5} = req.query;
    const filteredSkills = Array.from(availableSkills.values())
        .filter(s => s.shortname.toLowerCase().includes(search.toLowerCase()) || s.name.toLowerCase().includes(search.toLowerCase()));
    filteredSkills.sort((a, b) => a.shortname.localeCompare(b.shortname));
    const pageNumber = parseInt(page, 10) || 1;
    const pageSize = parseInt(size, 10) || 5;
    const startIndex = (pageNumber - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedSkills = filteredSkills.slice(startIndex, endIndex);
    res.header('Content-Type', 'application/json')
    res.send({
        total: filteredSkills.length,
        page: pageNumber,
        size: pageSize,
        data: paginatedSkills,
    });
}

async function getImage(req, res) {
    const skill = availableSkills.get(req.params.shortname)
    if (!!skill) {
        res.header('Content-Type', 'image/png');
        res.setHeader('Cache-Control', 'public, max-age=86400');
        res.setHeader('Expires', new Date(Date.now() + 86400000).toUTCString());
        let contents = readFileSync(__dirname + '/static/' + skill.icon);
        let buffer = await sharp(contents).toBuffer()
        res.send(buffer);
    } else {
        res.status(404)
        res.send()
    }
}

async function respond(req, res, type) {
    console.log("%s - Rendering %s banner for %s", new Date(), type, req.query)

    const bannerSize = getBannerSize(req.query['bs'])
    const logoSize = getLogoSize(req.query['ls'])
    const color = getColor(req.query['c'])
    const rgbColor = hexToRGB(color)
    const hasBrand = !!req.query['b']
    let skills = req.query['s']?.split(',') || []
    if (typeof skills === 'string') {
        skills = [skills]
    }

    const window = createSVGWindow()
    const document = window.document
    registerWindow(window, document)

    const svg = SVG(document.documentElement).viewbox(`0 0 ${bannerSize.w} ${bannerSize.h}`)
    svg.rect(bannerSize.w, bannerSize.h).fill(color)
    const linkBannershake = svg.link("https://bannershake.com").target('_blank')
    linkBannershake.text("Generated by bannershake.com")
        .move(bannerSize.w - 20, bannerSize.h / (bannerSize.h === 500 ? 4 : 6))
        .fill(rgbColor.luminance < 0.5 ? 'white' : 'black')
        .css({
            'writing-mode': 'tb',
            'transform': 'rotate(180deg)',
            'transform-origin': 'center'
        })

    if (hasBrand) {
        svg.line(lineOptions.x, lineOptions.yMargin, lineOptions.x, bannerSize.h - lineOptions.yMargin)
            .stroke({color: rgbColor.luminance < 0.5 ? 'white' : 'black', width: lineOptions.width})
        const brand = await getBrandImage(req.query['b'], rgbColor)
        if (!!brand) {
            const circle = svg.circle(maxBrandImageSize)
                .move(70, (bannerSize.h / 2) - (maxBrandImageSize / 2))
            svg.image(brand)
                .size(maxBrandImageSize, maxBrandImageSize)
                .move(70, (bannerSize.h / 2) - (maxBrandImageSize / 2))
                .clipWith(circle)
        }
    }

    const grid = getLogoGrid(bannerSize, logoSize, hasBrand)
    let index = 0
    let logoArea = logoSize + 2 * logoMargin
    let offscreenLogos = []
    for await (const skill of parseSkills(skills)) {
        const logo = await getSkillImage(skill, logoSize, rgbColor)
        if (!logo) {
            continue
        }

        const coord = nextCoordinate(index, logo.scale, grid, logoArea, bannerSize)
        if (coord.offscreen) {
            offscreenLogos.push(skill.name)
        } else {
            const link = svg.link(skill.url).target('_blank')
            link.image(logo.data)
                .size(logo.scale ? logoSize * 2 : logoSize, logoSize)
                .move(coord.x, coord.y)
        }
        index = coord.nextIndex
    }

    if (type === 'svg') {
        res.header('Content-Type', 'image/svg+xml');
        res.send(svg.svg());
    }
    if (type === 'json') {
        res.header('Content-Type', 'application/json')
        res.send({
            query: req.originalUrl.includes('?') ? req.originalUrl.substring(req.originalUrl.indexOf('?') + 1) : undefined,
            data: svg.svg(),
            size: bannerSize,
            offscreen: offscreenLogos
        })
    }
}

function parseSkills(skills) {
    return skills.map(skill => availableSkills.get(skill))
        .filter(infos => infos)
}

function getLogoSize(size) {
    if (!size) {
        return 40
    }
    switch (size) {
        case 's':
            return 52
        case 'm':
            return 80
        case 'l':
            return 106
        default:
            return 80
    }
}

function getBannerSize(size) {
    const defaultSize = {
        w: 1584,
        h: 396
    }
    if (!size) {
        return defaultSize
    }
    switch (size) {
        case 'l':
            return {
                w: 1584,
                h: 396
            }
        case 't':
        case 'b':
            return {
                w: 1500,
                h: 500
            }
        default:
            return defaultSize
    }
}

function getColor(color) {
    if (!color) {
        return '#FFFFEF'
    }
    return decodeURIComponent(color)
}

async function getBrandImage(imageUrl, bgColor) {
    try {
        const response = await fetch(decodeURIComponent(imageUrl));
        if (!response.ok) {
            return defaultBrandImage(bgColor)
        }

        const img = await response.arrayBuffer()
        let buffer = await sharp(img)
            .resize(maxBrandImageSize, maxBrandImageSize, {
                fit: sharp.fit.contain,
                background: {
                    r: bgColor.r,
                    g: bgColor.g,
                    b: bgColor.b,
                }
            })
            .toBuffer();
        return "data:image/png;base64," + buffer.toString('base64')
    } catch (e) {
        return defaultBrandImage(bgColor)
    }
}

function defaultBrandImage(bgColor) {
    const buffer = readFileSync(__dirname + `/static/logo-${bgColor.luminance < 0.5 ? 'white' : 'black'}.png`)
    return "data:image/png;base64," + buffer.toString('base64')
}

function hexToRGB(color) {
    let numbers = color.substring(1)
        .split(/(..)/)
        .filter(c => c)
        .map(c => parseInt(c, 16));
    return {
        r: numbers[0],
        g: numbers[1],
        b: numbers[2],
        luminance: (0.2126 * numbers[0] + 0.7152 * numbers[1] + 0.0722 * numbers[2]) / 255
    }
}

async function getSkillImage(skill, logoSize, bgColor) {
    const contents = readFileSync(__dirname + '/static/' + skill.icon)
    let width, height = logoSize
    let metadata = await sharp(contents).metadata()
    let scale = metadata.height < metadata.width / 2;
    if (scale) {
        width = 2 * logoSize
    }
    let buffer = await sharp(contents)
        .resize(width, height, {
            fit: sharp.fit.contain,
            background: {
                r: bgColor.r,
                g: bgColor.g,
                b: bgColor.b,
            }
        })
        .toBuffer()
    return {
        scale: scale,
        data: "data:image/png;base64," + buffer.toString('base64')
    }
}

function getLogoGrid(bannerSize, logoSize, hasBrand) {
    const logoArea = logoSize + 2 * logoMargin
    const logosArea = {
        w: hasBrand ? bannerSize.w - lineOptions.x : bannerSize.w,
        h: bannerSize.h
    }
    const nbPerRow = Math.floor(logosArea.w / logoArea)
    const nbPerColumn = Math.floor(logosArea.h / logoArea)
    return {
        nbPerRow: nbPerRow,
        nbPerColumn: nbPerColumn
    }
}

function nextCoordinate(index, scale, grid, logoArea, bannerSize) {
    let currentIndex = index + (scale ? 1 : 0);
    let remains = currentIndex % grid.nbPerRow;
    let shift = 1;
    if (index > 0 && scale && remains === 0) {
        remains++;
        shift++;
    }
    let x = remains + 1;
    let y = Math.floor(currentIndex / grid.nbPerRow) + 1;
    return {
        offscreen: y > grid.nbPerColumn,
        x: bannerSize.w - x * logoArea,
        y: bannerSize.h - y * logoArea,
        nextIndex: currentIndex + shift
    };
}

server.listen(port, () => {
    console.log('%s listening at %s', server.name, port);
});